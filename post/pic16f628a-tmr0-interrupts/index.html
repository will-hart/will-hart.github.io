<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>PIC16F628A TMR0 Interrupts | willhart.io</title>


  <link rel="icon" type="image/x-icon" href="/icons/icon_light_32x32.png">

  
<meta name="description" content="A quick tutorial on how to use interrupts on a PIC16F628A microcontroller. Posted on https://willhart.io" />
<meta property="og:description" content="A quick tutorial on how to use interrupts on a PIC16F628A microcontroller" />
<meta property="og:title" content="PIC16F628A TMR0 Interrupts" />
<meta property="og:url" content="https://willhart.io/post/pic16f628a-tmr0-interrupts/">
<meta property="og:type" content="article" />
<meta property="og:locale" content="en_AU" />


  <link rel="stylesheet" href="https://willhart.io/global.css?h=f83cd20cd0df26d72c2b" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Sono:wght@200..800&display=swap" rel="stylesheet">

  

  <!-- Cloudflare Web Analytics -->
  <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "310f93cab66a42c5a328f246cc053025"}'></script>
  <!-- End Cloudflare Web Analytics -->

  <!-- Light/Dark theme toggling -->
  <script type="text/javascript">
    const storageKey = "websiteTheme";

    // apply theme once we have a DOM
    document.addEventListener("DOMContentLoaded", () => {
      applyTheme();
    })

    // a function that toggles between light and dark theme
    const toggleTheme = () => {
      localStorage.setItem(storageKey, localStorage.getItem(storageKey) === "d" ? "l" : "d" );
      applyTheme();
    }

    // a function that actually applies the theme
    const applyTheme = () => {
      const useDarkTheme = localStorage.getItem(storageKey) === "d";
      document.getElementsByTagName("html")[0].className = useDarkTheme ? "dark" : "";
      document.getElementById("theme-toggle").textContent = useDarkTheme ? "üîÜ" : "üåë";
    }
  </script>

  <script type="speculationrules">
  {
    "prerender": [
      { "where": { "selector_matches": "a" } }
    ]
  }
  </script></head>

<body>
  <nav id="header">
    <a href="/" aria-label="Website Logo and Link to Home Page">
      <div id="logo" >&nbsp;</div>
    </a>
    <span>
      <button type="button" id="theme-toggle" aria-label="Toggle Theme" onClick="toggleTheme()">üåë</button>
      <a class="header-item" href="/post">POSTS</a>
      <a class="header-item" href="/tag">TAGS</a>
      <span class="header-item hide-when-slim">|</span>
      <a class="header-item hide-when-slim" href="/tag/projects">PROJECTS</a>
      <a class="header-item hide-when-slim" href="/tag/gamedev">GAMEDEV</a>
      <a class="header-item hide-when-slim" href="/tag/electronics">ELECTRONICS</a>
    </span>
  </nav>

  

<div class="container col mb mt">
  <h1>PIC16F628A TMR0 Interrupts</h1>
  <div class="col txtsm">
    <span>Posted by Will Hart on 2012-01-15</span>
    <div>
      <span>See also:</span>
      
      <a class="txtsm mr" href="https://willhart.io/tag/tutorials/">#tutorials</a>
      
      <a class="txtsm mr" href="https://willhart.io/tag/electronics/">#electronics</a>
      
    </div>
  </div>
</div>



<article class="container col mblg"><p>PIC TMR0 Interrupts, (or any PIC interrupts!) can be very confusing to setup,
but the rewards are well worthwhile! They allow you to have something happen
after a certain period of time, or for some interrupt types, something happens
when a button is pushed or a sensor reads a certain value. This means that the
microcontroller can automatically respond to user input. This article shows how
to set up a PIC16F628 TMR0 Interrupt, using MikroC.</p>
<h2 id="what-on-earth-are-interrupts">What on earth are interrupts?</h2>
<p>An interrupt is basically what it sounds like. It is a piece of code that
interrupts the main program and is executed when asked. Once the interrupt code
is executed, the normal program flow resumes. PIC Interrupts can be based on
PORT values (e.g. if PORTB is high) or on a ‚Äútimer overflow‚Äù.</p>
<p>On the PIC16F628A (and most PICs), a register is set aside to act as a counter.
This basically counts upwards as the microcontroller clock ‚Äúticks‚Äù. Counters are
commonly ‚Äú8 bits‚Äù, meaning they can count from 0 to 255. When the counter tries
to go past 255, it ‚Äúoverflows‚Äù and goes back to 0. If the correct settings are
made in the registers, this triggers the PIC TMR0 Interrupt code to run.</p>
<h2 id="why-would-i-use-interrupts">Why would I use interrupts?</h2>
<p>One way to get the same functionality as an interrupt is to put in some sort of
check in your main loop. Say you want to execute some code when a button is
pressed, in your program loop you could have something similar to the following:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">do </span><span>{
</span><span> </span><span style="color:#b48ead;">if </span><span>(BUTTON == </span><span style="color:#d08770;">1</span><span>)
</span><span>    {
</span><span>     execute your &quot;</span><span style="color:#a3be8c;">interrupt code</span><span>&quot;
</span><span>    }
</span><span>} </span><span style="color:#b48ead;">while</span><span>(</span><span style="color:#d08770;">1</span><span>);
</span></code></pre>
<p>This code looks fairly simple, but what if you have five buttons, or want
something to be checked on a regular basis (say every second). Or what if your
main loop has some extremely intensive calculations going on which means that
your test of whether the button is pushed or not may only happen every 20
seconds or so? Not a very good user experience!</p>
<p>An interrupt basically allows you to offload this functionality from the program
loop and let the micro hardware work out when the button is pushed or a second
has elapsed. This article focuses on PIC TMR0 interrupts, so if you are
interested in the PORT interrupts, then have a look at the datasheet!</p>
<h2 id="the-code">The Code</h2>
<p>I have broken out the interrupt configuration separately in the code below and
the comments should be fairly self explanatory. Basically we tell the micro what
source to use for its timer interrupts, ‚Äúscale‚Äù the timer and then turn on
interrupts.</p>
<p>The <code>OPTION_REG.T0CS</code> bit sets our source for the <code>TIMER0</code> clock. In this case I
am using the PIC16F628A internal clock and hence I clear (set to 0) this bit.</p>
<p>Recall that most TMR0 registers are 8-bit and can only count up to 255. We can
count the number of overflows in our interrupt code to get a certain time
period, or if we are really clever us the inbuilt prescaler to only call the
interrupt after a certain number of loops. If we set the prescaler to 1:64, like
we have below this means that we are only calling the interrupt every 64 times
that the TMR0 register overflows. The last 3 bits of <code>OPTION_REG</code> on the 628A
control the prescalar, and <code>OPTION_REG.PSA</code> sets what the prescaler is applied
to. We clear <code>OPTION_REG.PSA</code> to turn the prescaler on for TMR0 and set the last
three bits to 1 to set a 1:64 ratio. This can be done in one line with the
following:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span>OPTION_REG |= </span><span style="color:#d08770;">0x07
</span></code></pre>
<p>Finally we set <code>INTCON.GIE</code> and <code>INTCON.T0IE</code> to enable interrupts globally, and
<code>TMR0</code> in particular.</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">setup_interrupts</span><span>()
</span><span>{
</span><span>    </span><span style="color:#65737e;">// clear the TMR0 register
</span><span>    TMR0 = </span><span style="color:#d08770;">0</span><span>;
</span><span>
</span><span>    </span><span style="color:#65737e;">// set up interrupt registers
</span><span>    OPTION_REG.</span><span style="color:#bf616a;">T0CS </span><span>= </span><span style="color:#d08770;">0</span><span>;  </span><span style="color:#65737e;">// clock source is internal instruction clock
</span><span>    OPTION_REG.</span><span style="color:#bf616a;">PSA </span><span>= </span><span style="color:#d08770;">0</span><span>;   </span><span style="color:#65737e;">// prescaler assigned to TMR0
</span><span>    OPTION_REG |= </span><span style="color:#d08770;">0x07</span><span>;   </span><span style="color:#65737e;">// set the prescaler to 1:64 scale using an or
</span><span>    INTCON.</span><span style="color:#bf616a;">GIE </span><span>= </span><span style="color:#d08770;">1</span><span>;       </span><span style="color:#65737e;">// enable global interrupts
</span><span>    INTCON.</span><span style="color:#bf616a;">T0IE </span><span>= </span><span style="color:#d08770;">1</span><span>;      </span><span style="color:#65737e;">// enable TMR0 interrupt
</span><span>}
</span></code></pre>
<p>The main loop is pretty basic - it sets some standard PIC16F628A configurations,
calls the <code>setup_interrupts()</code> function declared above and then loops forever.</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>     </span><span style="color:#65737e;">// some standard PIC16F628A configuration
</span><span>     TRISA = </span><span style="color:#d08770;">0x00</span><span>;   </span><span style="color:#65737e;">// output
</span><span>     TRISB = </span><span style="color:#d08770;">0x07</span><span>;   </span><span style="color:#65737e;">// input
</span><span>     PORTA = </span><span style="color:#d08770;">0x01</span><span>;   </span><span style="color:#65737e;">// set PORTA to off
</span><span>     CMCON = </span><span style="color:#d08770;">0x07</span><span>;   </span><span style="color:#65737e;">// turn off comparators
</span><span>
</span><span>     </span><span style="color:#65737e;">// setup interrupts
</span><span>     </span><span style="color:#bf616a;">setup_interrupts</span><span>();
</span><span>
</span><span>     </span><span style="color:#65737e;">// loop forever and ever and ever and ...
</span><span>     </span><span style="color:#b48ead;">while</span><span>(</span><span style="color:#d08770;">1</span><span>);
</span><span>}
</span></code></pre>
<p>If we turn the interrupts on, we also need to define an interrupt function. This
is saved at the ‚Äúinterrupt vector‚Äù which is basically the location in memory
where the micro goes when an interrupt is called. This is done with the line
void <code>ISR() iv 0x0004</code> below. This declares an interrupt service routine (ISR)
that is located at interrupt vector <code>0x0004</code> in memory. From there its a
standard function!</p>
<p>Note that its considered poor practice to call functions from within your
interrupt, and if you do want a specific function called its best to set a flag
in your interrupt function and process this somewhere in your main loop. The
interrupt function below basically flips PORTA. This can be used to blink an
LED, sound a buzzer or whatever‚Ä¶ Once your interrupt routine has run you need
to restart the timer interrupts. This can be done by clearing <code>INTCON.TMR0IF</code>.</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">// the interrupt vector
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">ISR</span><span>() iv </span><span style="color:#d08770;">0x0004
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if</span><span>(INTCON.</span><span style="color:#bf616a;">TMR0IF </span><span>&amp;amp;&amp;amp; INTCON.</span><span style="color:#bf616a;">T0IE</span><span>)
</span><span>    {
</span><span>        PORTA = ~PORTA;
</span><span>        INTCON.</span><span style="color:#bf616a;">TMR0IF </span><span>= </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#65737e;">// unset the interrupt flag for TMR0
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="a-note-on-clocks">A note on ‚Äúclocks‚Äù</h2>
<p>One of the things I found most confusing when learning about PIC timers was the
concept of clocks, oscillators, resonators, etc. Why did some micros need an
external crystal oscillator, whilst others didn‚Äôt? What was the benefit of
having an external crystal, and what was the difference between a clock and a
crystal?</p>
<p>To cut to the chase, most micros will need some sort of external timing source
to function at all, and those that have this timing source built in are
frequently not very accurate. The best way to find out whether a timing source
is needed is to read the data sheet, but as an example the PIC16F628A has an
internal crystal but the PIC16F877A does not.</p>
</article>

<div class="container col">
  <h2>Comments</h2>
  <blockquote>Comments are powered by github and <a href="https://giscus.app">giscus</a></blockquote>
  <script src="https://giscus.app/client.js"
        data-repo="will-hart/will-hart.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzMjQ2NjY3Mzg="
        data-category="General"
        data-category-id="DIC_kwDOE1oFcs4CtiK6"
        data-mapping="og:title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
  </script>
</div>
</div>

  <footer id="footer">
    <div class="container col">
      This website was hand-made using Zola and Tera.
      All text and images are available under CC0 1.0 Universal and code under MIT unless otherwise specified. See <a href="https://github.com/will-hart/willhart.io/blob/main/LICENSE.md">LICENSE.md</a> for more.
    </div>
  </footer>
</body>

</html>
