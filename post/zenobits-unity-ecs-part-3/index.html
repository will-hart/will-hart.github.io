<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Zenobit&#x27;s Unity ECS (part 3) | willhart.io</title>


  <link rel="icon" type="image/x-icon" href="/icons/icon_light_32x32.png">

  
<meta name="description" content="Part 3 of a look into a custom ECS for Unity. Posted on https://willhart.io" />
<meta property="og:description" content="Part 3 of a look into a custom ECS for Unity" />
<meta property="og:title" content="Zenobit&#x27;s Unity ECS (part 3)" />
<meta property="og:url" content="https://willhart.io/post/zenobits-unity-ecs-part-3/">
<meta property="og:type" content="article" />
<meta property="og:locale" content="en_AU" />


  <link rel="stylesheet" href="https://willhart.io/global.css?h=f83cd20cd0df26d72c2b" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Sono:wght@200..800&display=swap" rel="stylesheet">

  

  <!-- Cloudflare Web Analytics -->
  <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "310f93cab66a42c5a328f246cc053025"}'></script>
  <!-- End Cloudflare Web Analytics -->

  <!-- Light/Dark theme toggling -->
  <script type="text/javascript">
    const storageKey = "websiteTheme";

    // apply theme once we have a DOM
    document.addEventListener("DOMContentLoaded", () => {
      applyTheme();
    })

    // a function that toggles between light and dark theme
    const toggleTheme = () => {
      localStorage.setItem(storageKey, localStorage.getItem(storageKey) === "d" ? "l" : "d" );
      applyTheme();
    }

    // a function that actually applies the theme
    const applyTheme = () => {
      const useDarkTheme = localStorage.getItem(storageKey) === "d";
      document.getElementsByTagName("html")[0].className = useDarkTheme ? "dark" : "";
      document.getElementById("theme-toggle").textContent = useDarkTheme ? "üîÜ" : "üåë";
    }
  </script>

  <script type="speculationrules">
  {
    "prerender": [
      { "where": { "selector_matches": "a" } }
    ]
  }
  </script></head>

<body>
  <nav id="header">
    <a href="/" aria-label="Website Logo and Link to Home Page">
      <div id="logo" >&nbsp;</div>
    </a>
    <span>
      <button type="button" id="theme-toggle" aria-label="Toggle Theme" onClick="toggleTheme()">üåë</button>
      <a class="header-item" href="/post">POSTS</a>
      <a class="header-item" href="/tag">TAGS</a>
      <span class="header-item hide-when-slim">|</span>
      <a class="header-item hide-when-slim" href="/tag/projects">PROJECTS</a>
      <a class="header-item hide-when-slim" href="/tag/gamedev">GAMEDEV</a>
      <a class="header-item hide-when-slim" href="/tag/electronics">ELECTRONICS</a>
    </span>
  </nav>

  

<div class="container col mb mt">
  <h1>Zenobit&#x27;s Unity ECS (part 3)</h1>
  <div class="col txtsm">
    <span>Posted by Will Hart on 2017-01-24</span>
    <div>
      <span>See also:</span>
      
      <a class="txtsm mr" href="https://willhart.io/tag/code/">#code</a>
      
      <a class="txtsm mr" href="https://willhart.io/tag/gamedev/">#gamedev</a>
      
    </div>
  </div>
</div>



<article class="container col mblg"><p>This is the third and final part of my three part series on the Entity Component
System we are using at @ZenobitStudios.</p>
<p><img src="https://willhart.io/post/zenobits-unity-ecs-part-3/ecs-background-2.png" alt="Zenobit ECS header (size: 1176x663px)" /></p>
<p>In the <a href="/post/zenobits-unity-ecs-part-1">first part</a>, I discussed what an ECS is, and
why we chose this architecture for our games. In the <a href="/zenobits-unity-ecs-part-2">second
part</a>, I talked through several areas in which an
ECS offers some potential advantages over the ‚Äústandard‚Äù Unity architecture. In
this third and final part, I‚Äôm going to describe a concrete example of how we
implemented a particular feature in our ECS.</p>
<h2 id="show-don-t-tell">Show don‚Äôt tell?</h2>
<p>In the previous post I presented some concrete examples using an example where
we have Entities (or game objects) with a <code>HealthComponent</code> and a
<code>ShieldComponent</code>. We‚Äôre going to take this a step further here and describe (in
a relatively hand wavy way) how we implemented ranged combat in our current game
project.</p>
<h2 id="unity-version">Unity Version</h2>
<p>I‚Äôll start by describing how I would normally implement a ranged combat system
in ‚ÄúUnity default‚Äù game architecture. I‚Äôm going to throw up a <a rel="noopener nofollow noreferrer" target="_blank" href="https://en.wikipedia.org/wiki/Sequence_diagram">sequence
diagram</a> to describe the system,
and then step through it bit by bit.</p>
<p><img src="https://willhart.io/post/zenobits-unity-ecs-part-3/unity_example-3.png" alt="Sequence Diagram for Unity Ranged Combat (size: 612x734px)" /></p>
<p>You can see there are three participants in this approach - a ‚ÄúRanged Attacker‚Äù,
a <code>HealthComponent</code> and a <code>ShieldComponent</code>, which are MonoBehaviour derived
classes attached to the same GameObject. First, let‚Äôs assume that we have some
sort of ranged attacker (hand wavy assumption #1) which raycasts / sphere
overlaps or whatever to find which enemies to hurt, and a weapon class (hand
wavy assumption #2) which stores weapon data.</p>
<p>Typically our attacker would then have a bunch of colliders to test against, and
there would be some logic:</p>
<pre data-lang="cs" style="background-color:#2b303b;color:#c0c5ce;" class="language-cs "><code class="language-cs" data-lang="cs"><span style="color:#65737e;">// in our ranged attacker MonoBehaviour
</span><span style="color:#b48ead;">private void </span><span style="color:#8fa1b3;">Update</span><span>()
</span><span>  {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">GetComponent</span><span>&lt;HealthComponent&gt;().</span><span style="color:#bf616a;">Health </span><span>&lt;= </span><span style="color:#d08770;">0</span><span>)
</span><span>    {
</span><span>        </span><span style="color:#bf616a;">Destroy</span><span>(</span><span style="color:#bf616a;">gameObject</span><span>);
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">var </span><span style="color:#bf616a;">hits </span><span>= </span><span style="color:#bf616a;">Physics</span><span>.</span><span style="color:#bf616a;">RaycastAll</span><span>(
</span><span>        </span><span style="color:#bf616a;">transform</span><span>.</span><span style="color:#bf616a;">position</span><span>, </span><span style="color:#bf616a;">transform</span><span>.</span><span style="color:#bf616a;">forward</span><span>, </span><span style="color:#bf616a;">weapon</span><span>.</span><span style="color:#bf616a;">Range</span><span>);
</span><span>
</span><span>    </span><span style="color:#b48ead;">foreach </span><span>(</span><span style="color:#b48ead;">var </span><span style="color:#bf616a;">hit </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">hits</span><span>)
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">var </span><span style="color:#bf616a;">health </span><span>= </span><span style="color:#bf616a;">hit</span><span>.</span><span style="color:#bf616a;">transform</span><span>.</span><span style="color:#bf616a;">GetComponent</span><span>&lt;HealthComponent&gt;();
</span><span>        </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">health </span><span>!= </span><span style="color:#d08770;">null</span><span>) </span><span style="color:#bf616a;">health</span><span>.</span><span style="color:#bf616a;">TakeDamage</span><span>(</span><span style="color:#bf616a;">weapon</span><span>.</span><span style="color:#bf616a;">Damage</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>This is the first loop in our sequence diagram, which is called on every
attacker‚Äôs <code>Update</code> method. If the attacker has health &gt; 0 (the <code>opt</code> bit in the
sequence diagram) then it calls the public <code>TakeDamage</code> method of any collided
<code>HealthComponents</code>. This then triggers the Health Component to find out if there
is an attached Shield Component. If there is, then it runs the shield‚Äôs logic
and reduce health by any remaining damage. It might look something like this:</p>
<pre data-lang="cs" style="background-color:#2b303b;color:#c0c5ce;" class="language-cs "><code class="language-cs" data-lang="cs"><span style="color:#b48ead;">public void </span><span style="color:#8fa1b3;">TakeDamage</span><span>(</span><span style="color:#b48ead;">float </span><span style="color:#bf616a;">damage</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">var </span><span style="color:#bf616a;">damageTaken </span><span>= </span><span style="color:#bf616a;">shield </span><span>== </span><span style="color:#d08770;">null
</span><span>        ? </span><span style="color:#bf616a;">damage
</span><span>        : </span><span style="color:#bf616a;">shield</span><span>.</span><span style="color:#bf616a;">GetRemainingDamage</span><span>(</span><span style="color:#bf616a;">damage</span><span>);
</span><span>    </span><span style="color:#bf616a;">Health </span><span>-= </span><span style="color:#bf616a;">damageTaken</span><span>;
</span><span>}
</span></code></pre>
<p>That‚Äôs pretty straightforward, and I‚Äôll leave the implementation of
<code>ShieldComponent::GetRemainingDamage()</code> up to your imagination. We now need a
way to remove dead GameObjects. We could do this in the <code>TakeDamage</code> method on
<code>HealthComponent</code>, and just check if health is less than or equal to 0 and
<code>Destroy()</code> the game object. This could cause difficulties though, as now there
is a possibility that objects are destroyed before they have the ability to
attack back. In theory, whichever objects are higher in the <code>Update</code> order now
have an advantage.</p>
<p>To fix this, we need to move our ‚Äúdeath‚Äù code out of the <code>TakeDamage</code> loop and
into an <code>Update</code> method. However, if you ran the code now, there would still be
a problem. By default, GameObjects are considered in the order that they were
instantiated in, then each MonoBehaviour on the GameObject has its <code>Update</code>
method called, in a slightly strange order.[1] We still can‚Äôt guarantee that
ordering in the hierarchy won‚Äôt have an impact on the outcome of ranged combat.
To fix this we need to set an order of script execution using the Script
Execution Order editor window. This way we can ensure all of the ranged attack
occurs before any <code>HealthComponent</code> destroys an entity. It works, but its a bit
confusing and arguably not very scalable.</p>
<p>There you go - the Unity system in a nutshell. Now let‚Äôs take a look at how our
ECS tackled this.</p>
<h2 id="ecs-version">ECS Version</h2>
<p>Once again, I‚Äôll throw out the sequence diagram for starters, then work through
it.</p>
<p><img src="https://willhart.io/post/zenobits-unity-ecs-part-3/ecs_example-6.png" alt="Sequence Diagram for ECS Ranged Combat (size: 969x513px)" /></p>
<p>Immediately you can see there are a few more moving pieces. Now we have three
systems alongside our two components. The components have the same data attached
but the <code>HealthComponent</code> now has a <code>DamageReceived</code> property (see note 2), but
all logic has been removed from them.</p>
<p>Our systems run one at a time, in the order in which they are added to the ECS
when we bootstrap it. Each runs an Update loop, which for the <code>RangedSystem</code> may
look like the following (see note 3):</p>
<pre data-lang="cs" style="background-color:#2b303b;color:#c0c5ce;" class="language-cs "><code class="language-cs" data-lang="cs"><span style="color:#b48ead;">public void </span><span style="color:#8fa1b3;">Update</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">foreach </span><span>(</span><span style="color:#b48ead;">var </span><span style="color:#bf616a;">enemy </span><span style="color:#b48ead;">in</span><span> \</span><span style="color:#bf616a;">_enemyMatcher</span><span>.</span><span style="color:#bf616a;">GetMatches</span><span>())
</span><span>    {
</span><span>        </span><span style="color:#bf616a;">enemy</span><span>.</span><span style="color:#bf616a;">Get</span><span>&lt;HealthComponent&gt;().</span><span style="color:#bf616a;">DamageReceived </span><span>+= </span><span style="color:#bf616a;">weapon</span><span>.</span><span style="color:#bf616a;">Damage</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<p>It doesn‚Äôt get too much simpler than that. Obviously there are some
implementation details around how we get the list of enemies to attack, (see
note 4) but the system itself couldn‚Äôt be easier to understand.</p>
<p>The <code>DamageSystem</code> then runs, calculating how much damage goes to health and how
much to shields. It might look like this:</p>
<pre data-lang="cs" style="background-color:#2b303b;color:#c0c5ce;" class="language-cs "><code class="language-cs" data-lang="cs"><span style="color:#b48ead;">public void </span><span style="color:#8fa1b3;">Update</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">foreach </span><span>(</span><span style="color:#b48ead;">var </span><span style="color:#bf616a;">enemy </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">Ecs</span><span>.</span><span style="color:#bf616a;">GetAll</span><span>&lt;HealthComponent&gt;())
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">var </span><span style="color:#bf616a;">shieldTaken </span><span>= </span><span style="color:#d08770;">0</span><span>;
</span><span>
</span><span>        </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">enemy</span><span>.</span><span style="color:#bf616a;">Has</span><span>&lt;ShieldComponent&gt;())
</span><span>        {
</span><span>          </span><span style="color:#bf616a;">shieldTaken </span><span>= </span><span style="color:#bf616a;">Mathf</span><span>.</span><span style="color:#bf616a;">Min</span><span>(
</span><span>              </span><span style="color:#bf616a;">enemy</span><span>.</span><span style="color:#bf616a;">DamageReceived</span><span>,
</span><span>              </span><span style="color:#bf616a;">enemy</span><span>.</span><span style="color:#bf616a;">Get</span><span>&lt;ShieldComponent&gt;().</span><span style="color:#bf616a;">Energy</span><span>);
</span><span>
</span><span>          </span><span style="color:#bf616a;">enemy</span><span>.</span><span style="color:#bf616a;">Get</span><span>&lt;ShieldComponent&gt;().</span><span style="color:#bf616a;">Energy </span><span>-= </span><span style="color:#bf616a;">shieldTaken</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#bf616a;">enemy</span><span>.</span><span style="color:#bf616a;">Health </span><span>-= (</span><span style="color:#bf616a;">enemy</span><span>.</span><span style="color:#bf616a;">DamageReceived </span><span>- </span><span style="color:#bf616a;">shieldTaken</span><span>);
</span><span>        </span><span style="color:#bf616a;">enemy</span><span>.</span><span style="color:#bf616a;">DamageReceived </span><span>= </span><span style="color:#d08770;">0</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<p>This looks like a ‚Äúlot‚Äù of code, but it combines the
<code>HealthComponent::TakeDamage()</code> and <code>ShieldComponent::GetRemainingDamage()</code>
methods from our Unity implementation into one place. Basically we allocate the
damage between shields and health and update them accordingly.</p>
<p>Finally we have our <code>DeathSystem</code> which removes entities when they die. It
probably looks something like this:</p>
<pre data-lang="cs" style="background-color:#2b303b;color:#c0c5ce;" class="language-cs "><code class="language-cs" data-lang="cs"><span style="color:#b48ead;">public void </span><span style="color:#8fa1b3;">Update</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">foreach </span><span>(</span><span style="color:#b48ead;">var </span><span style="color:#bf616a;">health </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">Ecs</span><span>.</span><span style="color:#bf616a;">GetAll</span><span>&lt;HealthComponent&gt;())
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">health</span><span>.</span><span style="color:#bf616a;">Health </span><span>&lt;= </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#bf616a;">Ecs</span><span>.</span><span style="color:#bf616a;">Destroy</span><span>(</span><span style="color:#bf616a;">health</span><span>.</span><span style="color:#bf616a;">Entity</span><span>);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Again, we can tell at a glance <em>exactly</em> what the code does, and we can
guarantee without any configuration or magic that it won‚Äôt be executed until
after all damage has been dealt out.</p>
<p>As the systems operate on a ‚Äúbatch‚Äù of Components in order, and components are
complete standalone, then it makes race conditions unlikely. While Unity does
provide a workable solution to this issue in the Script Execution Order
settings, the ECS approach is <em>failsafe</em> in that it protects against race
conditions by default.</p>
<h2 id="comparing-the-two">Comparing the two</h2>
<p>So I‚Äôm sure you could look at the Unity or ECS code and suggest ways they could
be improved. However, they are after all just examples for illustration, and a
bit hand wavy as I promised.</p>
<p>Looking back at the two, the ECS architecture has a few more moving pieces, and
it probably results in a bit more code being written. However in my mind at
least, it provides a much simpler, more loosely coupled structure than the Unity
approach. Importantly:</p>
<ol>
<li>None of the Systems depend on any of the other systems</li>
<li>Each of the Systems contains all the necessary logic to perform their
function (recall that this also makes refactoring our code significantly
easier)</li>
<li>The Systems do one thing, and only one thing</li>
<li>The Components just hold data, they don‚Äôt do anything else</li>
</ol>
<p>In my mind this makes for a more flexible, more extensible architecture.
Hopefully I‚Äôve given you some insight into why we picked our particular approach
for game architecture, and how we get it to work. I‚Äôm sure you have your own
opinions and that‚Äôs totally fine by me!</p>
<h2 id="notes">Notes</h2>
<ol>
<li>I ran a few tests in Unity with some simple scripts to work out what was
going on here. Strangely, it seemed that the execution order of
MonoBehaviours differed on game objects depending on whether they were in the
editor hierarchy or instantiated while the game was running. This has
implications for game logic, and can create some pretty weird bugs if you
aren‚Äôt careful - actually this might be a good topic for another blog post!</li>
<li>In practice we store a list of structs in the DamageReceived property, which
lets the system handle multiple different damage types and effects, but I‚Äôm
trying to keep things manageable here :)</li>
<li>See part 2 of this series for details of the Matcher class</li>
<li>In practice we use Unity‚Äôs colliders and a bridging MonoBehaviour to inject
collision data into the ECS. The bridging class is very simple and can be
reused for any entity which receives collisions.</li>
</ol>
</article>

<div class="container col">
  <h2>Comments</h2>
  <blockquote>Comments are powered by github and <a href="https://giscus.app">giscus</a></blockquote>
  <script src="https://giscus.app/client.js"
        data-repo="will-hart/will-hart.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzMjQ2NjY3Mzg="
        data-category="General"
        data-category-id="DIC_kwDOE1oFcs4CtiK6"
        data-mapping="og:title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
  </script>
</div>
</div>

  <footer id="footer">
    <div class="container col">
      This website was hand-made using Zola and Tera.
      All text and images are available under CC0 1.0 Universal and code under MIT unless otherwise specified. See <a href="https://github.com/will-hart/willhart.io/blob/main/LICENSE.md">LICENSE.md</a> for more.
    </div>
  </footer>
</body>

</html>
